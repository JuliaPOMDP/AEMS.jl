# AEMS

[![Build Status](https://travis-ci.org/JuliaPOMDP/AEMS.jl.svg?branch=master)](https://travis-ci.org/JuliaPOMDP/AEMS.jl)
[![Coverage Status](https://coveralls.io/repos/JuliaPOMDP/AEMS.jl/badge.svg?branch=master&service=github)](https://coveralls.io/github/JuliaPOMDP/AEMS.jl?branch=master)

Implements anytime error minimization search (AEMS) solver for POMDPs. This algorithm was originally described in

> Ross, St√©phane, and Brahim Chaib-Draa. "AEMS: An Anytime Online Search Algorithm for Approximate Policy Refinement in Large POMDPs." IJCAI. 2007.

Specifically, this solver is AEMS2, which outperforms AEMS1 in nearly all published experiments.

# Installation

```julia
Pkg.clone("https://github.com/JuliaPOMDP/AEMS.jl")
```


# Quick Use

```julia
using POMDPs, POMDPToolbox, AEMS, POMDPModels

pomdp = BabyPOMDP()
solver = AEMSSolver()
planner = solve(solver, pomdp)

# once you have a belief b
a = action(planner, b)
```

# Solver Options

* `n_iterations` Maximum number of fringe expansions during one action. Defaults to 1000.
* `max_time` Maximum time (in seconds) to spend on one action. Defaults to 1 second.
* `updater` The updater used to propagate beliefs in the tree. Defaults to a discrete updater.
* `lower_bound` Defaults to a fixed-action policy.
* `upper_bound` Defaults to a policy generated by FIB.
* `root_manager` Determines how the root changes once an action is taken and an observation is received. This process is further described below. Allowed values are `:clear`, `:belief`, `:user`. Defaults to `:clear`.

# Root Management

Once an action is taken and an observation is received, the root of the search tree becomes the updated belief. However, due to the structure of `POMDPs.jl`, the planner is not made aware of the resulting observation. Therefore we provide three different ways to manage the root.

1. **Clearing the tree after each action**. This solves the root issue by making a new graph with the current belief as the node, but it's probably less efficient to throw away the tree and start from scratch for each call to `action`.
Tree clearing is the default behavior, but if you want to be explicit you can call `AEMSSolver` with the option `root_manager = :clear`.

2. **Searching through child beliefs of previous root.** The updated belief should be equal to one of the child beliefs of the previous root.
We can set the root to be whichever of the children match the updated belief.
However, this requires `==` to be defined for the belief type you are using.
Further, the beliefs must *exactly* match (no tolerance for slight numerical differences).
If none of the child nodes match the belief provided to `action`, then an error is thrown (perhaps it should just clear the tree and start over).
Note also that multiple child beliefs can be identical. In this case the first matching belief is set to be the root (perhaps it should select the one which has the tightest bounds).
To use this method, call `AEMSSolver` with the option `root_manager = :belief`.

3. **The user can provide the planner with the action taken and observation received.**
The planner can then follow these down the tree to the next belief node.
To provide this information, the user can call `update_root(planner, a, o)`, where `a` and `o` are the action and observtion.
To use this method, call `AEMSSolver` with the option `root_manager = :user`.
Note that `update_root` will throw an error if the `root_manager` is not set to `:user`; don't mess with the root unless you specify that it's the user's job.
Unfortunately, the user can't personally call `update_root` after each action/observation pair during simulation.
Nor do existing simulators take care to update the planner (only the belief).
Therefore, jj
```julia
if planner.root_manager == :user
    update_root(planner, a, o)
end
```

### how does this look?
another option

### here we go
yes


# Visualization
Once you have a planner and have called `action`, you can use the following code to bring up an interactive tree in a Chrome browser window. Click a node to expand/unexpand it.

```julia
using D3Trees

tree = D3Tree(planner)      # creates a visualization tree
inchrome(tree)              # opens chrome tab to show visualization tree
```
